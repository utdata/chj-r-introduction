---
title: "CHJ R Track Day 2, Part 2: Summarizing"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(tidyverse)
library(janitor)
library(learnr)
library(lubridate)
knitr::opts_chunk$set(echo = FALSE)

deaths <- read_csv("data-raw/chj_mn_opiate_deaths_data.csv") %>% clean_names()

deaths_clean <- deaths %>% 
  mutate(
    birth_clean_date = birth_date %>% mdy(),
    death_clean_date = death_date %>% mdy(),
    injury_clean_date = injury_date %>% mdy(),
  )

```

## Goals for this section

- Calculating new data
- Summarizing data



## Calculating or updating data

The verb to change data in your data frame is [mutate()](https://dplyr.tidyverse.org/reference/mutate.html). You can use this to calculate new column of data based on other columns, or to replace data with a mutation of the original.

We'll use `mutate()` to convert our text-based dates to a real datetime object. We'll be using the [lubridate](https://lubridate.tidyverse.org/) package to help us, but we installed it yesterday and included it in the libraries at the top of our project.

### Using mutate to convert dates

We'll show this first in this learning environment before fixing the data in your project.

```{r convert-date, exercise=T}
deaths %>% 
  mutate(
    # creates new date column
    birth_clean_date = birth_date %>% mdy()
  ) %>% 
  # just to show the new/old cols
  select(birth_date, birth_clean_date)
```

I put the value inside the `mutate()` on a line by itself to make it clearly readable what we are doing. I can do multiple mutations by adding a comma and return after line 4 and adding another rule. I also put the `_clean_` part of the name in the middle so we can still use `ends_with("_date")` within our selects.

Let's break this down a little:

- Within the mutate call, we name the new column first (`birth_clean_date`) and then "fill" it with the right side of the equation. If we wanted to update the existing column, we would use `birth_date` on the left side of the equation, too, but that can be risky because you want to see what the mutation is doing vs the original data in case anything goes awry.
- On the right side of the equation we are starting with the column we want to convert, `birth_date` but then use a pipe` %>% mdy()` to convert that value.
- The `mdy()` part on the right side tells lubridate what order the date values are in. If we were starting with 1992/7/18, then we would use `ymd()`.

BORING DETAIL: You might see this written elsewhere as `mutate(birth_date_clean = mdy(birth_date))`, where the column you are converting is inside the `mdy()` function. I like the tidyverse notation using the pipe because nested rules can get confusing if there are more than one. Others may disagree, but they didn't write this tutorial.

### Calculate a new column with math

We don't have two number columns in our opioid data, so here is an example of creating a new column using math from the `mtcars` data set of automobile statistics. We are creating a "horsepower per cylinder", which is probably not a real thing. Again, the `mutate()` step names the new column first on the left side equation, then sets the result of the right side of the equation for each row.

```{r mtcars-math, exercise=T, exercise.eval=T}
mtcars %>% 
  mutate(
    hp_cyl= hp/cyl
  ) %>% 
  select(hp, cyl, hp_cyl)
```

### Mutate on your own

In your own project, use the convert dates example above to write a mutate rule to convert all three date columns in `deaths` into new "_clean_" columns, but  **assign the result back into a new data frame called `deaths_clean`**. _After_ you've reassigned the data frame, print the `deaths_clean` data frame and pipe in into a `select()` to show all six date columns so you can compare them.

I want you to do this in your own project in RStudio because it is easier to write code there than in this learning environment, but I include a practice session below with a hint in case you have trouble.

```{r convert-date-practice, exercise=T, exercise.lines=10}
deaths
```

<div id="convert-date-practice-hint">
```r
deaths_clean <- deaths %>% 
  mutate(
    birth_clean_date = birth_date %>% mdy(),
    death_clean_date = death_date %>% mdy(),
    injury_clean_date = injury_date %>% mdy()
  )

deaths_clean %>% 
  select(ends_with("_date"))
```
</div>

- After you've written and tested your code, write a Markdown annotation above it explaining the code.

## Summarizing data

Summarizing data in R typically takes two steps: 1) Group the rows based on some value in the data, 2) Aggregate those groups by counting the rows or doing math on values.

The Group and Aggregate combo can be confusing. We'll watch the video below to get a visual understanding of the concept. It's part of a series on [Basic Data Journalism Function](https://vimeo.com/showcase/7320305).

![](https://vimeo.com/showcase/7320305/video/435910349)

The verbs we use in R are [group_by](https://dplyr.tidyverse.org/reference/group_by.html) and [summarize](https://dplyr.tidyverse.org/reference/summarise.html).

BORING TIDBIT: Hadley Wickham is from New Zealand, so there are both the Queen's English `summarise()` and Americanized `summarize()` functions, but they do exactly the same thing. Unfortunately for Americans, summarise arrives first in alphabetical order in type-assist.

### Basic group and sum

When we group and sum, we are usually counting records or doing math on a value. We only have one number in our data, so we'll start with that.

**THE QUESTION:** What is the average and median age of the deaths by gender?

Read the code and guess how it works, then run it and then we'll walk through it line-by-line.

```{r group-mean, exercise=T}
deaths_clean %>% 
  group_by(gender) %>% 
  summarize(
    avg =  mean(age_years),
    mdn =  age_years %>% median()
  )
```

Well, the average and median are not very divergent, which hints at a normal distribution for age. Females skew a little older. But this is about the code:

- I use `gender` in the `group_by()` step to order/group all the data by `F` rows first and then `M` rows. Any operations following this step are performed WITHIN each group.
- In the `summarize()` step I broke down the step into individual lines so we can read them more easily. I first name the new column, just like we do in `mutate()`. I then "fill" that column with the right-side of the equation.
- For the "avg" column I wrote the rule in "nested" style, where the column goes inside the `mean()` function.
- For the "mdn" column I wrote the rule in "tidyverse" style using the ` %>% ` pipe.

You shouldn't mix up your nesting/tidyverse style like this, but I wanted to you to see both methods. In this case, the nested style _might_ be a little easier to understand, but I like the consistency of using tidyverse style.

### Grouping multiple columns

The more columns you add into the `group_by()` the more little groups are formed. We'll get a little fancy here with some date parsing, as well.

**THE QUESTION:** How have deaths differed by race by year?


```{r group-cnt, exercise=T, exercise.setup="prep-deaths-date", exercise.lines=10}
deaths_clean %>%
  group_by(
    yr = death_clean_date %>% year(),
    race
  ) %>% 
  summarize(
    cnt = n()
  ) %>% 
  arrange(yr, cnt %>% desc())
```

I'm throwing several new things in here:

- In the `group_by` I'm grouping by two columns, the "year of death" and `race`.
  - In that first group, I create a name for the new group result with `yr =`. I then "fill" that group result with our cleaned date field, but I pluck out just the "year" by piping it into the lubridate function that gets years from dates: ` %>% year()`. (I could nest this as `year(death_clean_date)`, but now I'm trying to be tidy and consistent.)
  - The second grouping value is `race`. This means with both grouping values in there the data is organized by all our 2005 African American rows first, then 2005 American Indian rows, etc., until we get to the next year.
- For `summarize()` we only have one aggregation, but is a new function for us.
  - We are calling our new column name `cnt`, short for count.
  - The function `n()` is simply returning the "number" of rows in each group. i.e, counting the rows.
- Lastly, I use the `arrange()` function to sort the date first by `yr` ascending (the default), then by the highest count in descending order.

### Shortcuts for counting

We do a lot of grouping and counting in data science, so there are some shortcuts. I wanted to show the long way first because the concept is foundational, but I use these shortcuts in practice a lot.

#### Using count()

The `count()` function includes the `group_by` and `summarize(n())` all in one. You feed it the columns you want to group and count.

```{r count-example, exercise=T, excercise.setup="prep-deaths-date"}
deaths_clean %>% 
  count(race)
```

#### Using tabyl()

For quick looks at counts and percentages of a group, the janitor package has the [tabyl](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html) function that is quite useful. This example uses `adorn_pct_formatting()` to make the percentages pretty and then arranges by the highest percent.

```{r tabyl-example, exercise=T, exercise.setup="prep-deaths-date"}
deaths_clean %>% 
  tabyl(race) %>% 
  adorn_pct_formatting() %>% 
  arrange(percent %>% desc())
```

### Summaries on your own

In your own project, use summaries to:

- Get the average age by `hispanic_ethnicity`, along with the number of rows in each group. This will take a traditional `group_by()` and `summarize()` combination.
- Get counts by year. You can use `count()`, but you'll have to parse the death_clean_date to group by the year, like I did above.
  - BONUS: Try renaming the "n" column to "deaths" using the `rename()` function. It works similar to mutate where you name the new column first.
  
Again, I want you to do this in your own project but have provided a hint the code block below if you need it.


```{r sums-own, exercise=T, exercise.lines=10}

```


<div id="sums-own-hint">
```r
# avg age by hispanic
deaths_clean %>% 
  group_by(hispanic_ethnicity) %>% 
  summarize(
    avg = age_years %>% mean(),
    cnt = n()
  )
  
# count by year
deaths_clean %>% 
  count(
    yr = death_clean_date %>% year()
  ) %>% 
  rename(cnt = n)
```
</div>

---

We are done for day 2.