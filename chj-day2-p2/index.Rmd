---
title: "CHJ R Track Day 2, Part 2: Summarizing"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
library(tidyverse)
library(janitor)
library(learnr)
library(lubridate)
knitr::opts_chunk$set(echo = FALSE)

deaths <- read_csv("data/chj_mn_opiate_deaths_data.csv") %>% clean_names()

deaths_clean <- deaths %>% 
  mutate(
    birth_clean_date = birth_date %>% mdy(),
    death_clean_date = death_date %>% mdy(),
    injury_clean_date = injury_date %>% mdy(),
  )

```

## Goals for this section

We'll build on our wrangling skills and learn how to summarize our data.

- Calculating new data with `mutate()`
- Summarizing data with `group_by()`, `summarize()` and `arrange()`.

We'll continue using the opioid deaths data to explore certain functions, then add to our practice quests with new challenges.

## Calculating or updating data

The verb to change data in your data frame is [mutate()](https://dplyr.tidyverse.org/reference/mutate.html). You can use this to calculate new columns of data based on other columns, or to replace data with a mutation of the original.

To demonstrate `mutate()` we'll convert our text-based dates in the `deaths` dataframe into to a real datetime object. We'll be using the [lubridate](https://lubridate.tidyverse.org/) package to help us, which we installed yesterday but haven't talked much about it yet.

If we select and glimpse the deaths data, we can see the dates are `<chr>` data types, which is text and not a real date we can do math on.

1. Review the code below and imagine how it will work, then run it.

```{r glimpse-death, exercise=T, exercise.eval = T}
deaths %>%
  select(ends_with("_date")) %>% 
  glimpse()
```


### Using mutate to convert dates

Within `mutate()` we name the new column first, then fill it with a value. In this case we are filling the new column with a converted date. We'll walk through that below the code.

```{r convert-date, exercise=T}
deaths %>% 
  mutate(
    # creates new date column
    birth_clean_date = mdy(birth_date)
  ) %>% 
  # just to show the new/old cols
  select(birth_date, birth_clean_date) %>% 
  head()
```

Let's break this down a little:

- We put the mutate call on a line by itself to make it clear what we are doing. This way we can do multiple mutations by adding a comma and return after line 4 and adding another rule.
- Within the mutate call, we name the new column first (`birth_clean_date`) and then "fill" it with the right side of the equation. If we wanted to update the existing column, we would use `birth_date` on the left side of the equation, too, but that can be risky because you want to see what the mutation is doing vs the original data in case anything goes awry.
- On the right side of the equation we are wrapping the `birth_date` variable inside `mdy()` to convert that a date. The `mdy()` part tells lubridate what order the date values are in. If we were starting with 1992/7/18, then we would use `ymd()`. You can see other parsing options in the [lubridate cheatsheet](https://lubridate.tidyverse.org/).

There was thought in choosing `birth_clean_date` as a column name so we can still use `ends_with()` to select them if we want.

### Add other clean dates

1. Update the code below to add two new mutations creating `death_clean_date` and `injury_clean_date`.
1. After you've solved that, remove the old dates.
2. Update the code to also set that result into a new R object called `deaths_clean`.


```{r date-clean, exercise = T}
deaths %>% 
  mutate(
    birth_clean_date = mdy(birth_date)
  )
```

<div id="date-clean-hint">

```r
deaths %>% 
  mutate(
    birth_clean_date = mdy(birth_date),
    death_clean_date = mdy(death_date),
    injury_clean_date = mdy(injury_date)
  ) %>% 
  select(-c(birth_date, death_date, injury_date))
```

</div>

### Calculate a new column with math

We don't have two number columns in our opioid data, so here is an example of creating a new column using math from the `mtcars` data set of automobile statistics. Let's take a gander at the data first:

```{r mtcars, exercise = T, exercise.eval = T}
mtcars %>% glimpse()
```

We will create a "horsepower per cylinder" column, which is probably not a real thing. Again, the `mutate()` step names the new column first on the left side of the equation, then sets the result of the right side of the equation for each row.

```{r mtcars-math, exercise=T, exercise.eval=T}
mtcars %>% 
  mutate(
    hp_cyl = hp/cyl
  ) %>% 
  select(hp, cyl, hp_cyl)
```

## Summarizing data

Summarizing data in R typically takes two steps: 1) Group the rows based on some value in the data, 2) Summarize those groups by counting the rows or doing math on values.

The Group and Summarize combo can be confusing. We'll watch the video below to get a visual understanding of the concept. It's part of a series on [Basic Data Journalism Function](https://vimeo.com/showcase/7320305). The summarize part is called "Aggregate" in the video.

![](https://youtu.be/a3VNWYJoy5A)

The verbs we use in R are [group_by](https://dplyr.tidyverse.org/reference/group_by.html) and [summarize](https://dplyr.tidyverse.org/reference/summarise.html). The pair are often followed by [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.html) to sort the data.

> BORING TIDBIT: Hadley Wickham is from New Zealand, so there are both the Queen's English `summarise()` and Americanized `summarize()` functions, but they do exactly the same thing. Unfortunately for Americans, summarise arrives first in alphabetical order in type-assist. It doesn't matter which you use.

### Basic group and summarize

When we group and summarize, we are usually counting records or doing math on a value. We only have one number in our data, so we'll start with that.

**THE QUESTION:** What is the average age of the deaths by gender?

1. Read the code and guess how it works, then run it and then we'll walk through it line-by-line.

```{r group-mean, exercise=T}
deaths_clean %>% 
  group_by(gender) %>% 
  summarize(
    avg =  mean(age_years)
)
```

- We use `gender` in the `group_by()` step to order/group all the data by `F` rows first and then `M` rows. Any operations following this step are performed WITHIN each group.
- In the `summarize()` step we first have to name the new column, just like we do in `mutate()`. We then "fill" that column with the right-side of the equation, the `mean(age_years)`.

### Add a median age

1. Edit the chunk below to also add a summary for the median age. The function for median is ... `median()`. You do this by just adding another rule within summarize, much like we did with mutate.

```{r group-median, exercise = T}
deaths_clean %>% 
  group_by(gender) %>% 
  summarize(
    avg =  mean(age_years)
)
```

<div id="group-median-hint">

```r
deaths_clean %>% 
  group_by(gender) %>% 
  summarize(
    avg =  mean(age_years),
    med = median(age_years)
)

```

</div>

Well, the average and median ages are not very divergent, which hints at a normal distribution for age. Females skew a little older.

### Grouping multiple columns

The more columns you add into the `group_by()` the more little groups are formed. We'll get a little fancy here with some date parsing, as well.

**THE QUESTION:** How have deaths differed by race by year?

```{r group-cnt, exercise=T, exercise.lines=10}
deaths_clean %>%
  group_by(
    yr = year(death_clean_date),
    race
  ) %>% 
  summarize(
    cnt = n()
  ) %>% 
  arrange(yr, desc(cnt))
```

We're throwing several new things in here:

- In the `group_by` we group by two columns, the "year of death" and `race`.
  - In that first group, we create a name for the new group result with `yr =`. We then "fill" that group result with our cleaned date field, but we pluck out just the "year" putting our `death_clean_date)` inside lubridate function `year()`. This give us just the YYYY part of the date.
  - The second grouping value is `race`. This means with both grouping values in there the data is organized by all our 2005 African American rows first, then 2005 American Indian rows, etc., until we get to the next year.
- For `summarize()` we only have one aggregation, but is a new function for us.
  - We are calling our new column name `cnt`, short for count.
  - The function `n()` is simply returning the "number" of rows in each group. i.e, counting the rows.
- Lastly, we use the `arrange()` function to sort the date first by `yr` ascending (the default), then by the highest count in descending order.

### Shortcuts for counting

We do a lot of grouping and counting in data science, so there are some shortcuts. We wanted to show the long way first because the concept is foundational, but we use these shortcuts in practice a lot.

#### Using count()

The `count()` function includes the `group_by` and `summarize(n())` and `arrange()` all in one. You feed it the columns you want to group and count.

- You can also name the new count column with `name = "new_name"`
- You can sort the data in descending order by the count with `sort = TRUE`

Here is the count version of the same code as above.

```{r count-example, exercise=T}
deaths_clean %>% 
  count(
    yr = year(birth_clean_date),
    race, name = "cnt", 
    sort = TRUE
  )
```

We also name the converted year column while we are at it.

#### Using tabyl()

For quick looks at counts and percentages of a group, the janitor package has the [tabyl](https://cran.r-project.org/web/packages/janitor/vignettes/tabyls.html) function that is quite useful. This example uses `adorn_pct_formatting()` to make the percentages pretty and then arranges by the highest percent.

```{r tabyl-example, exercise=T}
deaths_clean %>% 
  tabyl(race) %>% 
  adorn_pct_formatting() %>% 
  arrange(percent %>% desc())
```

### Summaries on your own

1. Using `deaths_clean` data, find the average age and number of rows in each group by `hispanic_ethnicity`. This will take a traditional `group_by()` and `summarize()` combination.

```{r hisp-group, exercise = T}
deaths_clean
  
```

<div id="hisp-group-hint">
```r
deaths_clean %>% 
  group_by(hispanic_ethnicity) %>% 
  summarize(
    avg = age_years %>% mean(),
    cnt = n()
  )
```
</div>

## On your own practice

You'll find some Day 1, Part 1 quests for both the LESO and Maritime Reports data sets in the [Practice quests page](https://github.com/utdata/chj-r-introduction/blob/main/students/practice-quests.md).

---

We are done for for this session. Do the practice!
