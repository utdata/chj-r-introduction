---
title: "Dealing with strings and Dates with R"
author: "Andrew Ba Tran"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
---


```{r setup, include=FALSE, echo=FALSE}
library(tidyverse)
library(learnr)
library(lubridate)
library(gradethis)
library(DT)

messy <- data.frame(name=c("Bill Smith", "jane doe", "John Forest-William"),
                    email=c("bsmith@themail.com", "jdoe@themail.com", 
                            "jfwilliams$geemail.com"),
                    income=c("$90,000", "$140,000", "E8500"),
                    phone=c("(203) 847-334", "207-999-1122", "2128487345"),
                    activites=c("fishing, sailing, planting flowers", "reading, 
                                raising flowers, biking", "hiking, fishing"))
some_date <- "12-31-1999"


race <- read_csv("https://docs.google.com/spreadsheets/d/e/2PACX-1vS8SzaERcKJOD_EzrtCDK1dX1zkoMochlA9iHoHg_RSw3V8bkpfk1mpw4pfL5RdtSOyx_oScsUtyXyk/pub?gid=43720681&single=true&output=csv")


race_long <- race %>% 
  pivot_longer(cols=3:54,
               names_to="type",
               values_to="total") %>% 
  group_by(State, type) %>% 
  slice(1)

race_longer <- race_long %>% 
  separate(type, c("count_type", "race_ethnicity"), 
                 sep="_",
                 extra="merge")

race_long_deaths <- race_longer %>% 
  filter(count_type=="Deaths") %>% 
  filter(race_ethnicity!="Total") %>% 
  filter(!str_detect(race_ethnicity, "Ethnicity_")) %>% 
  group_by(State) %>% 
  mutate(percent_deaths=round(total/sum(total, na.rm=T)*100,2))


```

## stringr

Sometimes, you're going need to deal with weird text.

Here are some tools from the **stringr** package that should be useful.

First, we'll load the library and some data, assigning it to the object "messy."

```{r install_stringr, warning=F, message=F}
#install.packages("stringr")
library(stringr)

messy <- data.frame(name=c("Bill Smith", "jane doe", "John Forest-William"),
                    email=c("bsmith@themail.com", "jdoe@themail.com", 
                            "jfwilliams$geemail.com"),
                    income=c("$90,000", "$140,000", "E8500"),
                    phone=c("(203) 847-334", "207-999-1122", "2128487345"),
                    activites=c("fishing, sailing, planting flowers", "reading, 
                                raising flowers, biking", "hiking, fishing"))

datatable(messy)

```


What problems do you see?

**Tasks**

1. Split name into First name and Last name
2. Convert names to title case
3. Create a new variable identifying bad email addresses
4. Convert income to a new number in US dollars
5. Create a new variable containing area code
6. Creating a new variable counting how many activities each person is engaged in
7. Break activities into a set of useful dummy codes


| Function | What function does |
| ------ | ------------------------ |
| `str_length()` | figure out length of string |
| `str_c()` | combine strings |
| `str_sub()`    | substitute string |
| `str_detect()`    | detect string in string |
| `str_count()`    | count strings |
| `str_to_upper()`   | convert string to upper case |
| `str_to_lower()`   | convert string to lower case |
| `str_to_title()`   | convert the first letter of each word to upper case |
| `str_trim()`   | eliminate trailing white space |




### String length

`str_length(string)` counts the number of characters in each element of a string or character vector.

```{r str_length}
x <- c("Bill", "Bob", "William")
str_length(x)
```

Why do you need to know this? Well, sometimes you have county FIPS codes that are 4 characters instead of 5. This will help locate them and let you change them easier.

### Combine strings

`str_c(strings, sep="")`

It's like the equivalent of =concatenate in Excel.

But there are a couple of quirks

```{r str_c}
data <- data.frame(place=c("HQ", "HQ", "HQ"),
                   id=c("A", "B", "C"),
                   number=c("001", "002", "003"))

datatable(data)
```

We can add a string to each value in the *number* column this way:

```{r str_c2}
data <- data %>% 
  mutate(combined=str_c("Num: ", number))

datatable(data)
```


### subset strings

`str_sub(strings, start, end)` extracts and replaces substrings

```{r str_sub}
x <- "Dr. James"

str_sub(x, 1, 3)

```

```{r str_sub2}
str_sub(x, 1, 3) <- "Mr."
x
```

Negative numbers count from the right.

```{r str_sub3}
x <- "baby"
str_sub(x, -3, -1)
str_sub(x, -1, -1) <- "ies"
```


### detect matches

`str_detect(strings, pattern)` returns T/F

```{r str_detect1}
x <- c("Bill", "Bob", "David.Williams")
x
str_detect(x, "il")
```

### count matches

`str_count(strings, pattern)` count number of matches in a string

```{r str_count}
x <- c("Assault/Robbery/Kidnapping")
x
str_count(x, "/")

# How many offenses
str_count(x, "/") + 1
```


### extract matches

```{r str_extract}
x <- c("bsmith@microsoft.com", "jdoe@google.com", "jfwilliams@google.com")
str_extract(x, "@.+\\.com$")
```



### replace a pattern

`str_replace(strings, pattern, replacement)` replace a pattern in a string with another string

```{r str_replace}
x <- c("john smith", "mary todd", "bill holis")
str_replace(x, "[aeiou]", "-")

str_replace_all(x, "[aeiou]", "-")
```

### change case

`str_to_upper(strings)` is upper case
`str_to_lower(strings)` is lower case
`str_to_title(strings)` is title case

```{r x_case}
x <- c("john smith", "Mary Todd", "BILL HOLLIS")

str_to_upper(x)
str_to_lower(x)
```

### Exercise 11

Change this to title case

```{r x_case_test, exercise=TRUE}
x <- c("john smith", "Mary Todd", "BILL HOLLIS")

____________(x)
```

```{r x_case_test-solution}
x <- c("john smith", "Mary Todd", "BILL HOLLIS")

str_to_title(x)
```

```{r x_case_test-code-check}
grade_code()
```


### trim strings

`str_trim(strings)` remove white space at the beginning and end of string

```{r str_trim}
x <- c(" Assault", "Burglary ", " Kidnapping ")
str_trim(x)
```

### Exercise 12

One last **stringr** test: Remember the ` race_long_deaths` data frame?

```{r race_long_deaths}
datatable(race_long_deaths)
```

Please swap out "AIAN" with "American Indian and Alaska Native" and "NHPI" with "Native Hawaiian and Pacific Islander"

```{r str_replace_test, exercise=TRUE}
race_long_deaths %>% 
  mutate(race_ethnicity= str________(race_ethnicity, "____", "____")) %>% 
  mutate(race_ethnicity= str________(race_ethnicity, "____", "____"))

race_long_deaths
```

```{r str_replace_test-solution}
race_long_deaths %>% 
  mutate(race_ethnicity= str_replace(race_ethnicity, "AIAN", "American Indian and Alaska Native")) %>% 
  mutate(race_ethnicity= str_replace(race_ethnicity, "NHPI", "Native Hawaiian and Pacific Islander"))

race_long_deaths
```

```{r str_replace_test-code-check}
grade_code()
```


## lubridate


Dates come in as characters, most of the time.

You'll need to convert them into a date variable

We'll be using the **lubridate** package.

Here's an example of a **character variable** that might be in a data frame.

```{r ex1}
some_date <- "12-31-1999"
```

Convert that date into a **date variable** with the function **mdy()**

```{r ex2, warning=F, message=F}
# If you don't have lubridate installed yet uncomment the line below and run it
#install.packages("lubridate")

# NOTE: IF YOU GET AN ERROR ABOUTZ NOT HAVING A PACKAGE CALLED stringi
# UNCOMMENT AND RUN THE LINES BELOW IF YOU HAVE A WINDOWS MACHINE

#install.packages("glue", type="win.binary")
#install.packages("stringi", type="win.binary")
#install.packages("stringr", type="win.binary")
#install.packages("lubridate", type="win.binary")

# UNCOMMENT AND RUN THE LINES BELOW IF YOU HAVE A MAC MACHINE

#install.packages("glue", type="mac.binary")
#install.packages("stringi", type="mac.binary")
#install.packages("stringr", type="mac.binary")
#install.packages("lubridate", type="mac.binary")

library(lubridate)

mdy(some_date)
```

The `mdy()` function is very versatile. It stand for month-date-year.

And it'll be able to parse any version of that (with slashes or commas, or dashes) as long as that's the order of the information. 

Check it out:

```{r ex3}

data <- data.frame(First=c("Charlie", "Lucy", "Peppermint"),
                   Last=c("Brown", "van Pelt", "Patty"),
                   birthday=c("10-31-06", "2/4/2007", "June 1, 2005"))

data <- data %>% 
  mutate(DOB = mdy(birthday))

datatable(data)

```

### Reading dates

| Order of elements in date-time | Parse function |
| ------ | ------------------------ |
| year, month, day | `ymd()` |
| year, day, month | `ydm()` |
| month, day, year    | `mdy()` |
| day, month, year    | `dmy()` |
| hour, minute    | `hm()` |
| hour, minute, second    | `hms()` |
| year, month, day, hour, minute, second    | `ymd_hms()` |

### Accessing date parts

| Date component | Function |
| ------ | ------------------------ |
| Year | `year()` |
| Month | `month()` |
| Week    | `week()` |
| Day of year  | `yday()` |
| Day of month  | `mday()` |
| Day of week | `wday()` |
| Hour  | `hour()` |
| Minute  | `minute()` |
| Second  | `ymd_hms()` |
| Time zone  | `ymd_hms()` |

Now that we have the date in the right format, we can extract data from it with the functions above.

```{r example_more}
data <- data %>% 
  mutate(year=year(DOB),
         month=month(DOB, label=TRUE),
         day=day(DOB),
         weekday=wday(DOB, label=TRUE, abbr=FALSE))

datatable(data)
```

### Date arithmetic

The function `difftime()` extracts the number of days between two dates that are passed to it

```{r math}
# We're going to use the now() function which brings in the date for today

today <- now()

data <- data %>% 
  mutate(age=difftime(today, DOB))

datatable(data)
```

And how does that translate into years? 

With some math. We'll have to turn the column into a number, first.

```{r math2}
data %>% 
  mutate(age_years=as.numeric(age)/365.25) #.25 because of leap years

datatable(data)
```

That's a pretty good start for now. To see more functions and examples, check out [the vignette](https://cran.r-project.org/web/packages/lubridate/vignettes/lubridate.html) for **lubridate**.
